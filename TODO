MUST HAVE

NICE TO HAVE
* Multiple result-producing branches in program trees
* Multiple types, with crossover restricted to nodes of like type
* Coevolution
* Checkpointing and restoring populations
* Hooks for visualizers
* Overselecting strategy should have more flexible defaults
* Bias node selection in crossover by terminal/nonterminal status (i.e. node selection is 90% likely to choose an internal node)
* Tournament selection & coevolution
* Elite reproduction
* Rank selection
* Mutation
* De-serialize programs from S-expressions
* Optimize programs
* Adapters for exploiting parallelism (e.g. via Map/Reduce)

CODE QUALITY
* Attempts to breed an odd number of programs by crossover should be handled gracefully
* Do the tests rely too heavily on spying?
* Population is in danger of becoming a God Object, if it isn't already.
